/*
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 *
 * Copyright (C) Martino Pilia, 2015
 */

/*!
 * \file backend.h
 */

/*! Value returned by the parseModelData(Model3D*) when the model file
 * contains no useful data. */
#define PARSER_ERR_NO_DATA 1

/*! Value returned by the parseModelData(Model3D*) when the model file
 * contains incoherent data which do not match declarations in the header
 * of the .ply file. */
#define PARSER_ERR_INCOHERENT_DATA 2

/*!
 * Maximum number of chars in a string (for paths, filenames etc.)
 */
#define STR_LEN 200

/*!
 * Numerical tolerance for floating point comparison
 */
#define NUM_TOL 1e-7

/*!
 * Digits to be used in int representation on display.
 * The numbers displayed are padded with space to fill at least this number 
 * of characters.
 */
#define INT_DIGITS 7

/*!
 * Digits to be used in floating point representation. 
 * The numbers displayed are padded with space to fill at least this number 
 * of characters.
 */
#define FLO_DIGITS 8

/*!
 * Text (without newlines inside) to be inserted as comment in files 
 * generated by the program.
 */
#define PLY_OUTPUT_COMMENT "generated by pr1 project"

/*!
 * A well known mathematical constant.
 */
#define PI 3.14159

/*!
 * Path of the directory containing models (with final separator).
 */
#if defined(__APPLE__) || defined(__linux__)
    #define MODEL_DIR "Model/"
#else
    #define MODEL_DIR "Model\\"
#endif // defined(__APPLE__) || defined(__linux__)

/*!
 * This macro is a simple portable way to suppress unused variable warning
 * on most compilers. Note that this macro just suppress the warning
 * without side effects, but it does not provide any information to the
 * compiler on the effective usage of the variable or parameter: for such
 * purpose, see some C extension like the __unused__ value 
 * for __attribute__.
 */
#define UNUSED(x) (void) (x)

/* Macros for coloring text */
/*! Color text in red with STR_COL() or similar macros. */
#define ANSI_COL_RED "1"
/*! Color text in green with STR_COL() or similar macros. */
#define ANSI_COL_GRE "2"
/*! Color text in yellow with STR_COL() or similar macros. */
#define ANSI_COL_YEL "3"
/*! Color text in blue with STR_COL() or similar macros. */
#define ANSI_COL_BLU "4"
/*! Color text in magenta with STR_COL() or similar macros. */
#define ANSI_COL_MAG "5"
/*! Color text in cyan with STR_COL() or similar macros. */
#define ANSI_COL_CYA "6"

/* Macros for formatting text */
/*! Bold text with STR_ATT() or similar macros. */
#define ANSI_ATT_BOLD "1"
/*! Blinking text with STR_ATT() or similar macros. */
#define ANSI_ATT_BLINK "5"
/*! Underlined text with STR_ATT() or similar macros. */
#define ANSI_ATT_UNDERLINE "4"
/*! Dimmed text with STR_ATT() or similar macros. */
#define ANSI_ATT_DIM  "2"
/*! Invert foreground and background colort with STR_ATT() or similar macros. */
#define ANSI_ATT_REVERSE "7"
/*! Hidden text with STR_ATT() or similar macros. */
#define ANSI_ATT_HIDDEN "8"

/*! Reset text format and color with STR_ATT() or similar macros. */
#define ANSI_RES "\x1b[0m"

/*!
 * \brief Color the text.
 * 
 * This macro permits to color a given string literal.
 * @param arg String literal to be colored.
 * @param col A macro defining the color, see ANSI_COL_XXX definitions.
 * @return A string literal with the desired color formattation.
 * @note Text color requires an ANSI terminal to be effectively shown.
 * @note Text coloring and attribute macros should not be nested.
 */
#if defined(__APPLE__) || defined(__linux__)
    #define STR_COL(arg, col) "\x1b[3" col "m" arg ANSI_RES
#else // _WIN32
    #define STR_COL(arg, col) arg
#endif // defined(__APPLE__) || defined(__linux__)

/*!
 * \brief Format the text with an attribute.
 * 
 * This macro permits to format a given string literal with an attribute.
 * @param arg String literal to be formatted.
 * @param att A macro defining the attribute, see ANSI_ATT_XXX definitions.
 * @return A string literal with the desired formattation.
 * @note Text formatting requires an ANSI terminal to be effectively shown.
 * @note Text coloring and attribute macros should not be nested.
 */
#if defined(__APPLE__) || defined(__linux__)
    #define STR_ATT(arg, att) "\x1b[" att "m" arg ANSI_RES
#else // _WIN32
    #define STR_ATT(arg, att) arg
#endif // defined(__APPLE__) || defined(__linux__)

/*!
 * \brief Color the text.
 * 
 * This macro permits to color and format a given string literal.
 * @param arg String literal to be colored and formatted.
 * @param col A macro defining the color, see ANSI_COL_XXX definitions.
 * @param att A macro defining the attribute, see ANSI_ATT_XXX definitions.
 * @return A string literal with the desired color and formattation.
 * @note Text color and format require an ANSI terminal to be effectively shown.
 * @note Text coloring and attribute macros should not be nested.
 */
#if defined(__APPLE__) || defined(__linux__)
    #define STR_COL_ATT(arg, col, att) "\x1b[" att ";3" col "m" arg ANSI_RES
#else // _WIN32
    #define STR_COL_ATT(arg, col, att) arg
#endif // defined(__APPLE__) || defined(__linux__)

/*!
 * \brief Format the text with background color.
 * 
 * This macro permits to format a given string literal with a background color.
 * @param arg String literal to be formatted.
 * @param bgcol A macro defining the color, see ANSI_COL_XXX definitions.
 * @return A string literal with the desired background color.
 * @note Text color requires an ANSI terminal to be effectively shown.
 * @note Text coloring and attribute macros should not be nested.
 */
#if defined(__APPLE__) || defined(__linux__)
    #define STR_BG(arg, bgcol) "\x1b[4" bgcol "m" arg ANSI_RES
#else // _WIN32
    #define STR_BG(arg, bgcol) arg
#endif // defined(__APPLE__) || defined(__linux__)

/*!
 * \brief Format the text with a background color and an attribute.
 * 
 * This macro permits to format a given string literal with an attribute and
 * a background color.
 * @param arg String literal to be formatted.
 * @param bgcol A macro defining the color, see ANSI_COL_XXX definitions.
 * @param att A macro defining the attribute, see ANSI_ATT_XXX definitions.
 * @return A string literal with the desired formattation.
 * @note Text formatting requires an ANSI terminal to be effectively shown.
 * @note Text coloring and attribute macros should not be nested.
 */
#if defined(__APPLE__) || defined(__linux__)
    #define STR_BG_ATT(arg, bgcol, att) \
        "\x1b[" att ";4" bgcol "m" arg ANSI_RES
#else // _WIN32
    #define STR_BG_ATT(arg, bgcol, att) arg
#endif // defined(__APPLE__) || defined(__linux__)

/*! 
 * Type for the action chosen by user in the main_menu(Model3D). 
 */
typedef enum Action
{
    NULL_ACTION = 0, /*!< Null action which never exits from loops. */
    COL_FLAT = 1, /*!< Color the model with a flat coloration. */
    COL_GRAD = 2, /*!< Color the model with a gradient coloration. */
    COL_DIST = 3, /*!< Color the model with a distance-based coloration. */
    COL_RAND = 4, /*!< Color the model with a random coloration. */
    INFO = 5,     /*!< Show info about current model. */
    ROTATE = 6,   /*!< Show model in 3D viewer. */
    ANOTHER = 7,  /*!< Pick another model, discarding the current one. */
    SAVE = 8,     /*!< Save the model on a file. */
    EXIT = 9      /*!< Discard all and exit. */
} Action;

/*! 
 * Type for the direction chosen by user for a gradient coloration with the
 * function color_gradient(Model3D, ColorRGB, Direction).
 */
typedef enum Direction
{
    RL = 1, /*!< From right to left. */
    LR = 2, /*!< From left to right. */
    TB = 3, /*!< From top to bottom. */
    BT = 4, /*!< From bottom to top. */
    BF = 5, /*!< From back to front. */
    FB = 6  /*!< From front to back. */
} Direction;

/*! Define a type containing informations about the model. */
typedef struct Info Info;

/*! Define a type representing a RGB color. */
typedef struct ColorRGB ColorRGB;

/*! Define a type representing a triangular face in tridimensional space. */
typedef struct Face Face;

/*! Define a type representing a vertex in tridimensional space. */
typedef struct Vertex Vertex;

/*! Define a type representing a vector in tridimensional space. */
typedef struct Point3D Vector3D;

/*! Define a type representing a point in tridimensional space. */
typedef struct Point3D Point3D;

/*! Define a type representing a vector in tridimensional space. */
typedef struct Point3D Normal3D;

/*! Define a type containing the current model data for elaboration. */
typedef struct Model3D Model3D;

/*! Define a type containing informations about the model. */
struct Info
{
    Vertex *max_x;       /*! Vertex with maximum x component (rightmost). */
    Vertex *min_x;       /*! Vertex with minimum x component (leftmost). */
    Vertex *max_y;       /*! Vertex with maximum y component (top). */
    Vertex *min_y;       /*! Vertex with minimum y component (bottom). */
    Vertex *max_z;       /*! Vertex with maximum z component (front). */
    Vertex *min_z;       /*! Vertex with minimum z component (back). */
    Face *biggest_face;  /*! Face with maximum surface. */
    Face *smallest_face; /*! Face with minimum surface. */
    double tot_surface;  /*! Total surface of the model (sum of faces area). */
    double volume;       /*! Volume delimited by the model. */
};

/*!
 * Type representing a 3D model.
 */
struct Model3D
{
    char filename[STR_LEN + 1]; /*!< Model filename. */
    FILE *file_model;        /*!< Input file for current 3D model. */
    Face *faces_list;        /*!< Model faces. */
    Vertex *vertices_list;   /*!< Model vertices. */
    int n_vertices;          /*!< Number of vertices. */
    int n_faces;             /*!< Number of faces. */
    Vertex **vertices_array; /*!< A dinamycal array, indexing vertexes. */
    Face *last_face;         /*!< Pointer to the last face added to the list. */
    Vertex *last_vertex;     /*!< Pointer to the last vertex in the list. */
    Info info;               /*!< Field containing informations on the current 
                                 model, see struct Info */
};

/*!
 * Type representing a RGB color.
 */
struct ColorRGB
{
    int r; /*!< Red component [0,255]. */
    int g; /*!< Green component [0,255]. */
    int b; /*!< Blue component [0,255]. */
};

/*!
 * Type representing a triangular face.
 */
struct Face
{
    int index;      /*!< Face index. */
    double surface; /*!< Face area. */
    int v1;         /*!< First vertex index. */
    int v2;         /*!< Second vertex index. */
    int v3;         /*!< Third vertex index. */
    Vertex *v1p;    /*!< Pointer to first vertex. */
    Vertex *v2p;    /*!< Pointer to second vertex. */
    Vertex *v3p;    /*!< Pointer to third vertex. */
    Face *next;     /*!< Next face in list. */
    Face *prev;     /*!< Previous face in list. */
};

/*!
 * Type representing a point in tridimensional space with coordinates (x,y,z).
 */
struct Point3D
{
    float x; /*!< X coordinate. */
    float y; /*!< Y coordinate. */
    float z; /*!< Z coordinate. */
};

/*!
 * Type representing a vertex of the 3D model.
 */
struct Vertex
{
    int index;                 /*!< Vertex index. */
    Point3D vertexCoordinates; /*!< Vertex coordinates. */
    Normal3D vertexNormals;    /*!< Vertex normal. */
    ColorRGB vertexColor;      /*!< Vertex color. */
    Vertex *next;              /*!< Next vertex in list. */
    Vertex *prev;              /*!< Previous vertex in list. */
};

/*!
 * \brief Open file for OS X.
 * @param fn Name of the file.
 * @param dim_file String length of the filename parameter.
 * @param exe_path Value of argv[0].
 * @param mode Mode in which open the file.
 * @return The return value of fopen(FILE*, const char *) on the filename.
 */
FILE* osx_open_file(char *fn, int dim_file, char *exe_path, char *mode);

/*!
 * \brief Estrazione dati modello.
 * @param model Pointer to the model to be filled with parsed data.
 * @return Zero if parsing was done successfully, nonzero otherwise. The
 * return value may be compared with PARSER_ERR_NO_DATA or
 * PARSER_ERR_INCOHERENT_DATA macros to retrive its nature.
 */
int parse_model_data(Model3D *model);

/*!
 * \brief Setup model data to default values.
 * @param myModel Pointer to the model to be initialized.
 */
void init_model(Model3D *myModel);


/*! 
 * \brief Save the edited model in the desired file.
 * @param file Pointer to the file in which save the edited model.
 * @param myModel Model to be saved.
 */
void save_model(FILE *file, Model3D myModel);

/*!
 * \brief Apply a flat coloration to the model.
 * @param myModel Model to be colored.
 * @param c Desired color for coloration.
 * @return Zero if coloration was fine, nonzero otherwise.
 */
int color_flat(Model3D myModel, ColorRGB c);

/*!
 * \brief Apply a random coloration to the model.
 * @param myModel Model to be colored.
 * @return Zero if coloration was fine, nonzero otherwise.
 * @note Before calling this function, or another function which depends on it,
 * srand(unsigned int) must be called at least once in order to inizialize the 
 * random number generator.
 */
int color_random(Model3D myModel);

/*!
 * \brief Apply a distance-based coloration to the model.
 * @param myModel Model to be colored.
 * @param c Desired color for coloration.
 * @param p Point to which the coloration is referred.
 * @return Zero if coloration was fine, nonzero otherwise.
 */
int color_distance(Model3D myModel, ColorRGB c, Point3D p);

/*!
 * \brief Apply a gradient coloration to the model.
 * @param myModel Model to be colored.
 * @param c Desired color for coloration.
 * @param d Direction in which shade the color.
 * @return Zero if coloration was fine, nonzero otherwise.
 */
int color_gradient(Model3D myModel, ColorRGB c, Direction d);

/*!
 * \brief Compute distance coefficient for gradient coloration.
 * @param m Model to be colored.
 * @param v Current vertex to be colored.
 * @param d Direction for color gradient.
 */
float distance_coefficient(Model3D m, Vertex *v, Direction d);

/*!
 * \brief Drain the stdin buffer.
 * @note This function hangs, waiting for input, if stdin is already empty.
 */
void clear_stdin(void);

/*!
 * \brief Multiply a column vector for a matrix.
 * @param y Vector for the result.
 * @param a Matrix to be used.
 * @param x Array for the input vector.
 */
void apply_transformation_matrix(float y[3], float a[3][3], float x[3]);

/*!
 * \brief Apply an arbitrary rotation to a model.
 * @param m Model to be rotated.
 * @param o Point belonging to the rotation axis.
 * @param u Vector defining the direction of the rotation axis.
 * @param theta Rotation angle in radians.
 * @return Zero if elaboration was done successfully, nonzero otherwise.
 */
int rotation(Model3D m, Point3D o, Vector3D u, float theta);

/*!
 * \brief Search for vertices with maximum of minimum coordinates.
 * @param myModel Model containing vertices to be scanned.
 */
void rescan_vertices_info(Model3D *myModel);

/*!
 * \brief Add a vertex to the vertices list of the model.
 * @param model Model3D object containing model data.
 * @param item Vertex to be added to the list.
 * @param index Index of the vertex to be added.
 * @return A pointer to the allocation of the vertex.
 */
Vertex* vertex_add(Model3D *model, Vertex item, int index);

/*!
 * \brief Get the pointer to a vertex in the desried position in the list.
 * @param l First item of the list containing the desired item.
 * @param n Index (position) of the item in the list, beginning from the
 * head (i.e. the first element added). The index is zero based.
 */
Vertex* vertex_get(Vertex *l, int n);

/*!
 * \brief Add a face to the faces list of the model.
 * @param model Model3D object containing model data.
 * @param item Face to be added to the list.
 * @return A pointer to the allocation of the face.
 */
Face* face_add(Model3D *model, Face item);

/*!
 * \brief Check if the vertex is significative and eventually add it to
 * model info.
 * @param model Model3D object containing model data.
 * @param v Vertex to be checked.
 */
void update_vertices_info(Model3D *model, Vertex *v);

/*!
 * \brief Check if the face is significative and eventually add it to
 * model info.
 * @param model Model3D object containing model data.
 * @param v Face to be checked.
 */
void update_faces_info(Model3D *model, Face *f);

/*!
 * \brief Compute the euclidean distance between two points in space.
 * @param p1 First point.
 * @param p2 Second point.
 * @return Value of the distance between the two points.
 */
double euclidean_distance(Point3D p1, Point3D p2);

/*!
 * \brief Check if three points in tridimensional space belong to the 
 * same straight line.
 * @param p1 First point.
 * @param p2 Second point.
 * @param p3 Third point.
 * @return Zero if points are not aligned, nonzero otherwise.
 */
int aligned(Point3D p1, Point3D p2, Point3D p3);

/*!
 * \brief Compute the area of a triangle in tridimensional space.
 * @param f Face describing the triangle.
 * @return Value of triangle area.
 */
double triangle_surface(Face *f);

/*!
 * \brief Return a human readable description of a vertex.
 * @param s String to be filled with description.
 * @param v Vertex to be described.
 */
void vertex_to_string(char *s, Vertex *v);

/*!
 * \brief Return a human readable description of a face.
 * @param s String to be filled with description.
 * @param f Face to be described.
 */
void face_to_string(char *s, Face *f);

/*!
 * \brief Handles fatal errors, writing a descriptive error message and
 * closing the program.
 * @param fun_name String representing the name of the function which failed.
 * @param caller Name of the caller of the failed function.
 * @param file Name of the file in which the failure happened.
 * @param line Line number of the failed function invocation.
 * @note This procedure causes the termination of the program.
 */
void error_handler(char *fun_name, const char *caller, char *file, int line);

/*!
 * \brief Deallocate all dynamical resources owned by a Model3D object.
 */
void clear_model(Model3D m);

/*!
 * \brief Compute the mixed (box) product of three vectors 
 * in \f$ \mathbb{R}^3 \f$.
 * @param a First term of the product.
 * @param b Second term of the product.
 * @param c Third term of the product.
 * @return Value of the mixed product.
 */
double mixed_product(Point3D a, Point3D b, Point3D c);

/*!
 * \brief Compute the volume subtended by the model.
 * @param m Input 3D model.
 * @return Value of the volume.
 * @note The value is meaningful only if the model is a closed surface.
 * @note The value is meaningful only if the surface is orientable and the 
 * vertices of each face have a consistent order, with face normal according
 * to the right hand rule or to its opposite in the same way for all faces.
 */
double model_volume(Model3D m);

/*!
 * \brief Approximate the volume subtended by the model.
 * @param m Input 3D model.
 * @return An approximation of the volume.
 * @note The value is meaningful only if the model is a closed surface.
 * @note The approximation is bad with not small enough faces and fancy vertex
 * normals; a formal evaluation of the error was not done, but for the sample 
 * models it may be around 7-10%.
 */
double model_volume_approx(Model3D m);

/*!
 * \brief Compute info about the input model.
 * @param m Pointer to the model.
 */
void model_info(Model3D *m);
